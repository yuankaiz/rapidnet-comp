/****************
*
* Online compression with distributed hash list
*
*****************/

/*Materialized table*/
materialize(initPacket,infinity,infinity,keys(2,3,4:str)). /*Input packets at hosts*/
materialize(recvPacket,infinity,infinity,keys(2,3,4:str)). /*Received packets at hosts*/
materialize(link,infinity,infinity,keys(2)). /*Links between nodes*/
materialize(flowEntry,infinity,infinity,keys(2)). /*Links between routers and other devices*/
materialize(programID,infinity,infinity,keys(2)). /*Allow the user to specify program ID*/

/* Provenance tables*/
materialize(ruleExec, infinity, infinity, keys(4:list)).
materialize(provLink, infinity, infinity, keys()).
materialize(equiHashTable,infinity,infinity,keys(2)). /*Hash table for equivalence detection*/
materialize(provHashTable,infinity,infinity,keys(3:list)). /*Hash table for provenance query*/
materialize(recvAuxPkt, infinity, infinity, keys(2:cid))./*Auxiliary table for received packets*/

/* 'ID' is a keyword. Parse error on using id for type!
The workaround is to call it cid or chord id. */

#define SWITCH 0
#define HOST 1

/*Switch program*/
/*A hit in the routing table, forward the packet accordingly*/
prov_rs1_1 epacketTemp(@RLOC, Next, SrcAdd, DstAdd, Data, RID, R, List, Tag) :- 
	   packetProv(@Node, SrcAdd, DstAdd, Data, Tag), 
	   flowEntry(@Node, DstAdd, Next), 
	   link(@Node, Next), 
	   PID3 := f_sha1((("flowEntry"+ Node)+ DstAdd)+ Next), 
	   List := f_append(PID3), 
	   PID4 := f_sha1(("link"+ Node)+ Next), 
	   List4 := f_append(PID4), 
	   List := f_concat(List, List4), 
	   RLOC := Node, 
	   R := "rs1", 
	   RID := f_sha1((R+ RLOC)+ List).

prov_rs1_2 epacketCount(@RLOC, RID, R, List, a_COUNT<*>) :-
	   epacketTemp(@RLOC, Next, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   ruleExec(@RLOC, RID, R, List).

prov_rs1_3 ruleExec(@RLOC, RID, R, List) :- 
	   epacketCount(@RLOC, RID, R, List, Rcount),
	   Rcount == 0.

prov_rs1_4 provLink(@RLOC, RID, CurCount, Preloc, PreRID, PreCount) :-
	   epacketTemp(@RLOC, Next, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   PreCount := f_first(Tag),
	   CurCount := PreCount + 1,
	   TempTag1 := f_removeFirst(Tag),
	   Preloc := f_first(TempTag),
	   TempTag2 := f_removeFirst(TempTag1),
	   PreRID := f_first(TempTag2).

prov_rs1_5 packetProv(@Next, SrcAdd, DstAdd, Data, NewTag) :-
	   epacketTemp(@RLOC, Next, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   Count := f_first(Tag),
	   NewCount := Count + 1,
	   NewCountlist := f_append(NewCount),
	   TempNewTag1 := f_removeFirst(Tag),
	   TempNewTag2 := f_removeFirst(TempNewTag1),
	   TempNewTag3 := f_removeFirst(TempNewTag2),
	   RIDlist := f_append(RID),
	   Loclist := f_append(RLOC),
	   TempNewTag4 := f_concat(RIDlist, TempNewTag3),
	   TempNewTag5 := f_concat(Loclist, TempNewTag4),
	   NewTag := f_concat(NewCountlist, TempNewTag5).

/* Rules for normal execution without provenance */
rs1 packet(@Next, SrcAdd, DstAdd, Data, PIDHash) :-
        packet(@Node, SrcAdd, DstAdd, Data, PIDHash),
	flowEntry(@Node, DstAdd, Next),
	link(@Node, Next).
        
/*Host program*/
/* Hash on equivalence attributes*/
rh100 initPacketHash(@Node, SrcAdd, DstAdd, Data, PIDequi, ProgID) :-
    initPacket(@Node, SrcAdd, DstAdd, Data),
    programID(@Node, DstAdd, ProgID),
    PIDequi := f_sha1("" + Node + DstAdd).
    
rh101 initPacketCount(@Node, SrcAdd, DstAdd, Data, PIDequi, ProgID, a_COUNT<*>) :-
    initPacketHash(@Node, SrcAdd, DstAdd, Data, PIDequi, ProgID),
    equiHashTable(@Node, DstAdd, PIDequi).

rh102 equiHashTable(@Node, DstAdd, PIDequi) :-
    initPacketCount(@Node, SrcAdd, DstAdd, Data, PIDequi, ProgID, PIDcount),
    PIDcount == 0.

/* Execution of rh1 without provenance maintenance*/
rh103 packet(@Next, SrcAdd, DstAdd, Data, PIDHash) :-
    initPacketCount(@Node, SrcAdd, DstAdd, Data, PIDequi, ProgID, PIDcount),
    link(@Node, Next),
    PIDev := f_sha1("initPacket" + Node + SrcAdd + DstAdd + Data),
    PIDcount != 0,
/* Add program ID*/    
    PIDequiHash := f_append(PIDequi),
    PIDevHash := f_append(PIDev),
    PIDHash := f_concat(PIDequiHash, PIDevHash).

/* Execution of rh1 with provenance enabled*/
prov_rh1_1 epacketTemp(@RLOC, Next, SrcAdd, DstAdd, Data, RID, R, List, Tag) :- 
	   initPacketCount(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDcount),
	   link(@Node, Next),
	   PIDcount == 0,
	   PID := f_sha1(("link"+ Node)+ Next), 
	   List := f_append(PID), 
	   RLOC := Node, 
	   RID := f_sha1((R+ RLOC)+ List),
	   R := "rh1", 
	   Equilist := f_append(PIDequi),
	   PIDev := f_sha1(((("initPacket"+ Node)+ SrcAdd)+ DstAdd)+ Data),
           Evlist := f_append(PIDev),
	   Count := 0,
	   Countlist := f_append(Count),
	   InitProvNode := RLOC,
	   InitProvNodelist := f_append(InitProvNode),
	   InitProvHash := f_sha1("NULL"),
	   InitProvHashlist := f_append(InitProvHash),
	   TempTag1 := f_concat(Countlist, InitProvNodelist),
	   TempTag2 := f_concat(TempTag1, InitProvHashlist),
	   TempTag3 := f_concat(TempTag2, Equilist),
           Tag := f_concat(TempTag3, Evlist).	   

/*Receive a packet*/
prov_rh2_1 erecvPacketTemp(@RLOC, Node, SrcAdd, DstAdd, Data, RID, R, List, Tag) :-  
	   packetProv(@Node, SrcAdd, DstAdd, Data, Tag), 
	   DstAdd == Node, 
	   PID2 := f_sha1(((("packet"+ Node)+ SrcAdd)+ DstAdd)+ Data), 
	   List := f_append(PID2),
	   RLOC := Node, 
	   R := "rh2", 
	   RID := f_sha1((R+ RLOC)+ List).

prov_rh2_2 epacketCount(@RLOC, RID, R, List, a_COUNT<*>) :-
	   erecvPacketTemp(@RLOC, Node, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   ruleExec(@RLOC, RID, R, List).

prov_rh2_3 ruleExec(@RLOC, RID, R, List) :- 
	   epacketCount(@RLOC, RID, R, List, Rcount),
	   Rcount == 0.

prov_rh2_4 provLink(@RLOC, RID, CurCount, Preloc, PreRID, PreCount) :-
	   erecvPacketTemp(@RLOC, Node, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   PreCount := f_first(Tag),
	   CurCount := PreCount + 1,
	   TempTag1 := f_removeFirst(Tag),
	   Preloc := f_first(TempTag),
	   TempTag2 := f_removeFirst(TempTag1),
	   PreRID := f_first(TempTag2).

prov_rh2_5 recvPacket(@Node, SrcAdd, DstAdd, Data, NewTag) :- 
	   erecvPacketTemp(@RLOC, Node, SrcAdd, DstAdd, Data, RID, R, List, Tag),
	   Count := f_first(Tag),
	   NewCount := Count + 1,
	   NewCountlist := f_append(NewCount),
	   TempNewTag1 := f_removeFirst(Tag),
	   TempNewTag2 := f_removeFirst(TempNewTag1),
	   TempNewTag3 := f_removeFirst(TempNewTag2),
	   RIDlist := f_append(RID),
	   Loclist := f_append(RLOC),
	   TempNewTag4 := f_concat(RIDlist, TempNewTag3),
	   TempNewTag5 := f_concat(Loclist, TempNewTag4),
	   NewTag := f_concat(NewCountlist, TempNewTag5).


/* Handle provenance information for the output recv tuple*/
/* Create a tuple for provHashTable*/
ro1 provHashTable(@Node, PIDequi, RLOC, RID, Count) :-
	   recvPacket(@Node, SrcAdd, DstAdd, Data, Tag),
	   Count := f_first(Tag),
	   RemainTag1 := f_removeFirst(Tag),
	   Loc := f_first(RemainTag1),
	   RemainTag2 := f_removeFirst(RemainTag1),
	   RID := f_first(RemainTag2),
	   RemainTag3 := f_removeFirst(RemainTag2),
	   PID


ro2 recvPacketDecomp(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev, Hashlist) :-
	   recvPacketTemp(@Node, SrcAdd, DstAdd, Data, Tag),
	   PIDequi := f_first(Tag),
	   Remainlist := f_removeFirst(Tag),
	   PIDev := f_first(Remainlist),
	   Hashlist := f_removeFirst(Remainlist).

	   recvPacketDecomp(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev, Hashlist).

ro4 recvPacket(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev) :- 
	   recvPacketDecomp(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev, Hashlist).	

/* Execution of original rh2*/
rh2 recvPacket(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev) :-
	packet(@Node, SrcAdd, DstAdd, Data, PIDHash),
	PIDequi := f_first(PIDHash),
	PIDevHash := f_removeFirst(PIDHash),
	PIDev := f_first(PIDevHash),
	DstAdd == Node.

rh3 recvAuxPkt(@Node, PID, PIDequi, PIDev) :-
        recvPacket(@Node, SrcAdd, DstAdd, Data, PIDequi, PIDev),
        PID := f_sha1("recvPacket" + Node + SrcAdd + DstAdd + Data).	
